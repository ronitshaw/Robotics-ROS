ROS: an open-source Robot Operating System Paper Summary
1)This paper gives an overview of ROS, an opensource robot operating system.
2)ROS is not an operating system it provides a structured communications layer above the host operating systems of a heterogeneous compute cluster.
3)Writing soft wares for robot is difficult as the are many different types of robot and incorporate different kinds of hardware, making re-usability difficult.So writing a software for a robot from initial stage would take a lot of effort beyond individual capacity, so large scale software integration efforts in required.
4)These difficulties lead to the development of wide variety of frameworks,resulting in many robotics software systems. ROS, the framework described in this paper, is also the product of trade offs and prioritisation made during its design cycle.
5)The paper deals with the design goals of ROS,How ROS tries to implement them and how ROS handles common cases of robotics software developed.
6)The philosophical goals of ROS can be summarised as:
 • Peer-to-peer:A system built using ROS consists of a number of processes,potentially on a number of different hosts, connected at run-time in a peer-to-peer topology. Although frameworks based on a central server is problematic if the computers are connected in a heterogeneous.
  • Tools-based: Microkernel design, where a large number of small tools are used to build and run the various ROS components.Loss in efficiency is more than offset by the gains in stability and complexity management. 
  • Multi-lingual:ROS is language neutral. in some cases it adds support for a new language by wrapping an existing library. ROS uses a simple,language-neutral interface definition language (IDL) 
  • Thin: Much of the previous robotics code become so entangled with the middleware that it became difficult to “extract” its functionality and re-use it outside of its original context. To solve this all On ROS all driver and algorithm development takes place in standalone libraries that have no dependencies The ROS build system performs modular builds inside the source code tree, and the use of CMake makes it comparatively easy to follow this “thin” ideology. Placing virtually all complexity in libraries,and only creating small executable which expose library functionality to ROS, allows for easier code extraction and reuse. Testing is often far easier when code is factored into libraries,as standalone test programs can be written to exercise various features of the library. ROS re-uses code from numerous other open-source projects.To benefit from the continual community improvements, the ROS build system can automatically update source code from external repositories, apply patches, and so on. 
  • Free and Open-Source:The full source code of ROS is publicly available. ROS passes data between modules using inter-process communications, and does not require that modules link together in the same executable
7) Important Implementation feature of ROS is Nodes: Nodes are processes that perform computation.A system is typically comprised of many nodes.When many nodes are running, it is convenient to render the peer-to-peer communications as a graph, with processes as graph nodes and the peer-to-peer links as arcs.Nodes communicate with each other by passing messages.A node sends a message by publishing it to a given topic.A node that is interested in a certain kind of data will subscribe to the appropriate topic.In general, publishers and subscribers are not aware of each others’ existence. ROS also offers services with request and response modes.
8) The open architecture of ROS allows for the creation of a wide variety of tools. in describing the ROS a Tools designed to be used with ROS are: 

Debugging a single node: ROS is designed to minimize the difficulty of debugging. As its modular structure allows nodes undergoing active development to run alongside pre-existing, well-debugged nodes.Because nodes connect to each other at runtime, the graph can be dynamically modified. This “infrastructure” graph can be started and left running during an entire experimental session. Only the node(s) undergoing source code modification need to be periodically restarted, at which time ROS silently handles the graph modifications. This can result in a massive increase in productivity, particularly as the robotic system becomes more complex and interconnected 

Logging and playback: Any ROS message stream can be dumped to disk and later replayed. Importantly, this can all be done at the command line. To facilitate logging and monitoring of systems distributed across many hosts, the rosconsole library builds upon the Apache project’s log4cxx system to provide a convenient and elegant logging interface, allowing printf-style diagnostic messages to be routed through the network to a single stream called rosout 

Packaged subsystems: To allow for “packaged” functionality such as a navigation system, ROS provides a tool called roslaunch,This functionality can also significantly aid sharing and reuse of large demonstrations of integrative robotics research Collaborative Development: To support collaborative development, the ROS software system is organized into package. ROS provides a utility called rospack to query and inspect the code tree, search dependencies, find packages by name, etc. A set of shell expansions called rosbash is provided for convenience, accelerating command-line navigation of the system.The rospack utility is designed to support simultaneous development across multiple ROS package repositories. The open-ended nature of ROS packages allows for great variation in their structure and purpose: some ROS packages wrap existing software, such as Player or OpenCV, automating their builds and exporting their functionality. ROS repository includes only the base ROS communications infrastructure and graph-management tools.Software which actually builds robotic systems using ROSis provided in a second repository. 

Visualization and Monitoring: While designing and debugging robotics software, it often becomes necessary to observe some state while the system is running. ROS can exploit the dynamic nature of the connectivity graph to “tap into” any message stream on the system.A more powerful concept is a visualization program which uses a plugin architecture, this is done in the rviz program, which is distributed with ROS. Visualization panels can be dynamically instantiated to view a large variety of datatypes, such as images, point clouds, geometric primitives (such as object recognition results), render robot poses and trajectories, etc 

Composition of functionality:Sometimes multiple instantiations of a cluster are desired. ROS supports this by allowing nodes and entire roslaunch cluster-description files to be pushed into a child namespace. 

Transformations: Robotic systems often need to track spatial relationships between a mobile robot and some fixed frame of reference.To simplify and unify the treatment of spatial frames, a transformation system has been written for ROS, called tf. The tf system constructs a dynamic transformation tree which relates all frames of reference in the system.
